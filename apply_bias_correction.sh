#!/bin/bash

echo "üîß „É¢„Éá„É´„Éê„Ç§„Ç¢„ÇπË£úÊ≠£„ÇíÈÅ©Áî®..."

EC2_HOST="ubuntu@13.212.91.54"
KEY_PATH="~/.ssh/mlbot-key-1749802416.pem"

# „Éê„Ç§„Ç¢„ÇπË£úÊ≠£„Ç≥„Éº„Éâ„Çí‰ΩúÊàê
cat > bias_correction_patch.py << 'EOF'
# simple_improved_bot_with_trading_fixed.py„Å´ËøΩÂä†„Åô„Çã„Éê„Ç§„Ç¢„ÇπË£úÊ≠£„Ç≥„Éº„Éâ

import numpy as np
from collections import deque

class BiasCorrector:
    """‰∫àÊ∏¨ÂÄ§„ÅÆ„Éê„Ç§„Ç¢„Çπ„ÇíÂãïÁöÑ„Å´Ë£úÊ≠£"""
    
    def __init__(self, window_size=1000, initial_offset=0.15):
        self.predictions = deque(maxlen=window_size)
        self.initial_offset = initial_offset
        
    def add_prediction(self, pred):
        """‰∫àÊ∏¨ÂÄ§„ÇíË®òÈå≤"""
        self.predictions.append(pred)
        
    def get_bias_offset(self):
        """ÁèæÂú®„ÅÆ„Éê„Ç§„Ç¢„Çπ„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó"""
        if len(self.predictions) < 100:
            return self.initial_offset
        
        mean_pred = np.mean(list(self.predictions))
        # Âπ≥Âùá„Åå0.5„Å´„Å™„Çã„Çà„ÅÜ„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó
        offset = 0.5 - mean_pred
        # Ê•µÁ´Ø„Å™Ë£úÊ≠£„ÇíÈÅø„Åë„Çã
        return np.clip(offset, -0.3, 0.3)
        
    def correct_prediction(self, raw_pred):
        """‰∫àÊ∏¨ÂÄ§„ÇíË£úÊ≠£"""
        offset = self.get_bias_offset()
        
        # „Ç∑„Ç∞„É¢„Ç§„ÉâÈñ¢Êï∞„Åß„Çπ„É†„Éº„Ç∫„Å´Ë™øÊï¥
        # „Çà„ÇäÊÄ•Â≥ª„Å™Â§âÊèõ„Åß‰∏≠Â§ÆÂÄ§‰ªòËøë„ÅÆÊÑüÂ∫¶„Çí‰∏ä„Åí„Çã
        adjusted = raw_pred + offset
        corrected = 1 / (1 + np.exp(-8 * (adjusted - 0.5)))
        
        return float(np.clip(corrected, 0.0, 1.0))
    
    def get_stats(self):
        """Áµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó"""
        if len(self.predictions) == 0:
            return {}
        
        preds = list(self.predictions)
        return {
            'count': len(preds),
            'mean': np.mean(preds),
            'std': np.std(preds),
            'min': np.min(preds),
            'max': np.max(preds),
            'offset': self.get_bias_offset()
        }
EOF

ssh -i $KEY_PATH $EC2_HOST << 'REMOTE_EOF'
cd /home/ubuntu/mlbot

# 1. ÁèæÂú®„ÅÆ„Éú„ÉÉ„Éà„ÇíÂÅúÊ≠¢
echo "üõë ÁèæÂú®„ÅÆ„Éú„ÉÉ„Éà„ÇíÂÅúÊ≠¢..."
pkill -f simple_improved_bot_with_trading_fixed.py
sleep 3

# 2. „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Çí‰ΩúÊàê
echo "üíæ „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Çí‰ΩúÊàê..."
cp simple_improved_bot_with_trading_fixed.py simple_improved_bot_with_trading_fixed.py.backup_$(date +%Y%m%d_%H%M%S)

# 3. „Éê„Ç§„Ç¢„ÇπË£úÊ≠£„ÇíÁµÑ„ÅøËæº„Çì„Å†Êñ∞„Åó„ÅÑ„Éú„ÉÉ„Éà„Çí‰ΩúÊàê
echo "üìù „Éê„Ç§„Ç¢„ÇπË£úÊ≠£Áâà„Éú„ÉÉ„Éà„Çí‰ΩúÊàê..."
cat > simple_improved_bot_bias_corrected.py << 'EOF'
#!/usr/bin/env python3
"""
MLÂèñÂºï„Éú„ÉÉ„ÉàÔºà„Éê„Ç§„Ç¢„ÇπË£úÊ≠£ÁâàÔºâ
v3.1_improved„É¢„Éá„É´„ÅÆSELL„Éê„Ç§„Ç¢„Çπ„ÇíÂãïÁöÑ„Å´Ë£úÊ≠£
"""

import asyncio
import os
import sys
import logging
import numpy as np
from datetime import datetime, timedelta
from collections import deque
import json
import traceback
import aiohttp
import websockets
import redis.asyncio as redis
import onnxruntime as ort
from typing import Dict, List, Optional, Any
from pydantic import BaseModel
from src.utils.logger import Logger
from src.common.bybit_client import BybitRESTClient, BybitWebSocketClient

# „É≠„ÇÆ„É≥„Ç∞Ë®≠ÂÆö
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Improved Feature Generator„Çí‰ΩøÁî®
from improved_feature_generator_readonly import ImprovedFeatureGeneratorReadOnly as ImprovedFeatureGenerator

class BiasCorrector:
    """‰∫àÊ∏¨ÂÄ§„ÅÆ„Éê„Ç§„Ç¢„Çπ„ÇíÂãïÁöÑ„Å´Ë£úÊ≠£"""
    
    def __init__(self, window_size=1000, initial_offset=0.15):
        self.predictions = deque(maxlen=window_size)
        self.initial_offset = initial_offset
        self.correction_enabled = True  # Ë£úÊ≠£„ÅÆÊúâÂäπ/ÁÑ°Âäπ„ÇíÂà∂Âæ°
        
    def add_prediction(self, pred):
        """‰∫àÊ∏¨ÂÄ§„ÇíË®òÈå≤"""
        self.predictions.append(pred)
        
    def get_bias_offset(self):
        """ÁèæÂú®„ÅÆ„Éê„Ç§„Ç¢„Çπ„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó"""
        if len(self.predictions) < 100:
            return self.initial_offset
        
        mean_pred = np.mean(list(self.predictions))
        # Âπ≥Âùá„Åå0.5„Å´„Å™„Çã„Çà„ÅÜ„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó
        offset = 0.5 - mean_pred
        # Ê•µÁ´Ø„Å™Ë£úÊ≠£„ÇíÈÅø„Åë„Çã
        return np.clip(offset, -0.3, 0.3)
        
    def correct_prediction(self, raw_pred):
        """‰∫àÊ∏¨ÂÄ§„ÇíË£úÊ≠£"""
        if not self.correction_enabled:
            return raw_pred
            
        offset = self.get_bias_offset()
        
        # „Ç∑„Ç∞„É¢„Ç§„ÉâÈñ¢Êï∞„Åß„Çπ„É†„Éº„Ç∫„Å´Ë™øÊï¥
        # „Çà„ÇäÊÄ•Â≥ª„Å™Â§âÊèõ„Åß‰∏≠Â§ÆÂÄ§‰ªòËøë„ÅÆÊÑüÂ∫¶„Çí‰∏ä„Åí„Çã
        adjusted = raw_pred + offset
        corrected = 1 / (1 + np.exp(-8 * (adjusted - 0.5)))
        
        return float(np.clip(corrected, 0.0, 1.0))
    
    def get_stats(self):
        """Áµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó"""
        if len(self.predictions) == 0:
            return {}
        
        preds = list(self.predictions)
        buy_count = sum(1 for p in preds if p > 0.5)
        sell_count = len(preds) - buy_count
        
        return {
            'count': len(preds),
            'mean': np.mean(preds),
            'std': np.std(preds),
            'min': np.min(preds),
            'max': np.max(preds),
            'offset': self.get_bias_offset(),
            'buy_ratio': buy_count / len(preds) if len(preds) > 0 else 0,
            'sell_ratio': sell_count / len(preds) if len(preds) > 0 else 0
        }

class MLTradingBot:
    def __init__(self, testnet: bool = False):
        self.testnet = testnet
        self.logger = Logger()
        
        # ÂèñÂºïË®≠ÂÆö
        self.symbols = ['BTCUSDT', 'ETHUSDT', 'ICPUSDT']
        self.confidence_threshold = 0.50  # ‰ø°È†ºÂ∫¶ÈñæÂÄ§
        self.position_size_pct = 0.02  # „Ç¢„Ç´„Ç¶„É≥„Éà„Éê„É©„É≥„Çπ„ÅÆ2%
        self.max_positions = 3
        self.min_confidence = 0.50
        
        # „Éê„Ç§„Ç¢„ÇπË£úÊ≠£Âô®
        self.bias_corrector = BiasCorrector(window_size=1000, initial_offset=0.15)
        
        # DiscordË®≠ÂÆö
        self.discord_webhook = os.getenv("DISCORD_WEBHOOK")
        self.last_signal_time = {}
        self.signal_cooldown = 300  # 5ÂàÜ„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
        
        # RedisÊé•Á∂ö
        self.redis_client = None
        
        # „É¢„Éá„É´„Å®„Çπ„Ç±„Éº„É©„Éº
        model_path = os.getenv("MODEL__MODEL_PATH", "models/v3.1_improved/model.onnx")
        self.session = ort.InferenceSession(
            model_path,
            providers=['CPUExecutionProvider']
        )
        
        # „Çπ„Ç±„Éº„É©„Éº„Éë„É©„É°„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
        scaler_path = "models/v3.1_improved/manual_scaler.json"
        with open(scaler_path, 'r') as f:
            self.scaler_params = json.load(f)
        
        # Feature Generator
        self.feature_generator = ImprovedFeatureGenerator()
        
        # „Ç´„Ç¶„É≥„Çø„Éº
        self.prediction_count = 0
        self.signal_count = 0
        self.prediction_history = []
        
        # REST client
        self.rest_client = None
        
        # „Ç¢„Ç´„Ç¶„É≥„ÉàÊÉÖÂ†±
        self.current_balance = None
        self.open_positions = {}
        
        # ÊôÇÈñì„É¨„Éù„Éº„ÉàÁî®
        self.last_report_time = datetime.utcnow()
        self.hourly_predictions = {symbol: [] for symbol in self.symbols}
        
    async def initialize(self):
        """ÂàùÊúüÂåñÂá¶ÁêÜ"""
        try:
            # RedisÊé•Á∂ö
            self.redis_client = await redis.from_url(
                'redis://localhost:6379',
                decode_responses=False
            )
            
            # REST clientÂàùÊúüÂåñ
            self.rest_client = BybitRESTClient(testnet=self.testnet)
            await self.rest_client.__aenter__()
            
            # ÂàùÊúü„Éê„É©„É≥„ÇπÂèñÂæó
            await self.update_balance()
            
            logger.info("MLÂèñÂºï„Éú„ÉÉ„ÉàÔºà„Éê„Ç§„Ç¢„ÇπË£úÊ≠£ÁâàÔºâÂàùÊúüÂåñÂÆå‰∫Ü")
            
        except Exception as e:
            logger.error(f"ÂàùÊúüÂåñ„Ç®„É©„Éº: {e}")
            raise
    
    async def update_balance(self):
        """„Ç¢„Ç´„Ç¶„É≥„Éà„Éê„É©„É≥„Çπ„ÇíÊõ¥Êñ∞"""
        try:
            account_info = await self.rest_client.get_account_info()
            if account_info:
                self.current_balance = float(account_info.get('totalEquity', 0))
                logger.info(f"„Ç¢„Ç´„Ç¶„É≥„Éà„Éê„É©„É≥„ÇπÊõ¥Êñ∞: ${self.current_balance:.2f}")
        except Exception as e:
            logger.error(f"„Éê„É©„É≥„ÇπÊõ¥Êñ∞„Ç®„É©„Éº: {e}")
    
    def normalize_features(self, features: np.ndarray) -> np.ndarray:
        """ÁâπÂæ¥Èáè„ÇíÊ≠£Ë¶èÂåñ"""
        mean = np.array(self.scaler_params['means'])
        std = np.array(self.scaler_params['stds'])
        
        # „Çº„É≠Èô§ÁÆó„ÇíÈÅø„Åë„Çã
        std_safe = np.where(std == 0, 1.0, std)
        
        normalized = (features - mean) / std_safe
        return normalized
    
    async def predict(self, symbol: str) -> Optional[Dict[str, Any]]:
        """‰æ°Ê†º„ÅÆÂãï„Åç„Çí‰∫àÊ∏¨"""
        try:
            # ÁâπÂæ¥Èáè„ÇíÁîüÊàê
            features = await self.feature_generator.get_features(symbol)
            if features is None:
                return None
            
            # Ê≠£Ë¶èÂåñ
            normalized = self.normalize_features(np.array(features))
            
            # ‰∫àÊ∏¨
            input_data = normalized.reshape(1, -1).astype(np.float32)
            outputs = self.session.run(None, {'float_input': input_data})
            
            # ‰∫àÊ∏¨ÂÄ§„ÇíÊäΩÂá∫
            if len(outputs) > 1 and isinstance(outputs[1], list) and len(outputs[1]) > 0:
                prob_dict = outputs[1][0]
                raw_prediction = prob_dict.get(1, 0.5)
            else:
                raw_prediction = float(outputs[0][0])
            
            # „Éê„Ç§„Ç¢„ÇπË£úÊ≠£„ÇíÈÅ©Áî®
            self.bias_corrector.add_prediction(raw_prediction)
            prediction = self.bias_corrector.correct_prediction(raw_prediction)
            
            # ‰ø°È†ºÂ∫¶„ÇíË®àÁÆó
            confidence = abs(prediction - 0.5) * 2
            
            # ‰∫àÊ∏¨ÂõûÊï∞„ÇíÊõ¥Êñ∞
            self.prediction_count += 1
            
            result = {
                'symbol': symbol,
                'raw_prediction': raw_prediction,
                'corrected_prediction': prediction,
                'confidence': confidence,
                'direction': 'BUY' if prediction > 0.5 else 'SELL',
                'timestamp': datetime.utcnow()
            }
            
            # Â±•Ê≠¥„Å´ËøΩÂä†
            self.prediction_history.append({
                'symbol': symbol,
                'prediction': prediction,
                'raw_prediction': raw_prediction,
                'confidence': confidence,
                'timestamp': datetime.utcnow()
            })
            
            # ÊôÇÈñìÂà•Áµ±Ë®àÁî®„Å´‰øùÂ≠ò
            self.hourly_predictions[symbol].append(prediction)
            
            # Â±•Ê≠¥„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂà∂Èôê
            if len(self.prediction_history) > 2000:
                self.prediction_history = self.prediction_history[-2000:]
            
            return result
            
        except Exception as e:
            logger.error(f"{symbol}„ÅÆ‰∫àÊ∏¨„Ç®„É©„Éº: {e}")
            logger.error(traceback.format_exc())
            return None
    
    async def should_send_signal(self, symbol: str, confidence: float) -> bool:
        """„Ç∑„Ç∞„Éä„É´„ÇíÈÄÅ‰ø°„Åô„Åπ„Åç„ÅãÂà§Êñ≠"""
        if confidence < self.confidence_threshold:
            return False
        
        # „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥„ÉÅ„Çß„ÉÉ„ÇØ
        now = datetime.utcnow()
        if symbol in self.last_signal_time:
            elapsed = (now - self.last_signal_time[symbol]).total_seconds()
            if elapsed < self.signal_cooldown:
                return False
        
        return True
    
    async def send_discord_signal(self, prediction: Dict[str, Any]):
        """DiscordÈÄöÁü•„ÇíÈÄÅ‰ø°"""
        if not self.discord_webhook:
            return
        
        try:
            symbol = prediction['symbol']
            direction = prediction['direction']
            confidence = prediction['confidence']
            raw_pred = prediction['raw_prediction']
            corrected_pred = prediction['corrected_prediction']
            
            # ÁèæÂú®„ÅÆ‰æ°Ê†º„ÇíÂèñÂæó
            ticker = await self.rest_client.get_ticker(symbol)
            if not ticker:
                return
            
            current_price = float(ticker.get('lastPrice', 0))
            
            # „É°„ÉÉ„Çª„Éº„Ç∏„Çí‰ΩúÊàêÔºà„Éê„Ç§„Ç¢„ÇπË£úÊ≠£ÊÉÖÂ†±„ÇíÂê´„ÇÄÔºâ
            color = 0x00ff00 if direction == 'BUY' else 0xff0000
            
            embed = {
                "title": f"üéØ ML Signal #{self.signal_count + 1} - {symbol}",
                "description": f"ÊñπÂêë: **{direction}**",
                "color": color,
                "fields": [
                    {"name": "‰ø°È†ºÂ∫¶", "value": f"{confidence*100:.1f}%", "inline": True},
                    {"name": "‰æ°Ê†º", "value": f"${current_price:,.2f}", "inline": True},
                    {"name": "‰∫àÊ∏¨ÂÄ§", "value": f"Raw: {raw_pred:.4f}\nCorrected: {corrected_pred:.4f}", "inline": True},
                    {"name": "„Éê„Ç§„Ç¢„ÇπË£úÊ≠£", "value": f"Offset: {self.bias_corrector.get_bias_offset():.4f}", "inline": True}
                ],
                "timestamp": datetime.utcnow().isoformat()
            }
            
            # Áµ±Ë®àÊÉÖÂ†±„ÇíËøΩÂä†
            stats = self.bias_corrector.get_stats()
            if stats:
                embed["fields"].append({
                    "name": "‰∫àÊ∏¨Áµ±Ë®à",
                    "value": f"Buy/SellÊØî: {stats['buy_ratio']:.1%}/{stats['sell_ratio']:.1%}",
                    "inline": False
                })
            
            async with aiohttp.ClientSession() as session:
                await session.post(self.discord_webhook, json={"embeds": [embed]})
            
            self.last_signal_time[symbol] = datetime.utcnow()
            self.signal_count += 1
            logger.info(f"DiscordÈÄöÁü•ÈÄÅ‰ø°: {symbol} {direction} (‰ø°È†ºÂ∫¶: {confidence*100:.1f}%)")
            
        except Exception as e:
            logger.error(f"DiscordÈÄöÁü•„Ç®„É©„Éº: {e}")
    
    async def execute_trade(self, prediction: Dict[str, Any]):
        """ÂèñÂºï„ÇíÂÆüË°å"""
        try:
            symbol = prediction['symbol']
            direction = prediction['direction']
            confidence = prediction['confidence']
            
            # „Éù„Ç∏„Ç∑„Éß„É≥„Çµ„Ç§„Ç∫„ÇíË®àÁÆó
            if not self.current_balance:
                await self.update_balance()
            
            position_value = self.current_balance * self.position_size_pct
            
            # ÁèæÂú®„ÅÆ‰æ°Ê†º„ÇíÂèñÂæó
            ticker = await self.rest_client.get_ticker(symbol)
            if not ticker:
                return
            
            current_price = float(ticker.get('lastPrice', 0))
            
            # Êï∞Èáè„ÇíË®àÁÆó
            qty = position_value / current_price
            
            # ÊúÄÂ∞èÂèñÂºïÂçò‰Ωç„Å´‰∏∏„ÇÅ„Çã
            if symbol == 'BTCUSDT':
                qty = round(qty, 3)
            elif symbol == 'ETHUSDT':
                qty = round(qty, 2)
            elif symbol == 'ICPUSDT':
                qty = round(qty, 0)
            
            # Ê≥®Êñá„ÇíÈÄÅ‰ø°
            side = 'Buy' if direction == 'BUY' else 'Sell'
            
            order = await self.rest_client.place_order(
                symbol=symbol,
                side=side,
                order_type='Market',
                qty=qty,
                reduce_only=False
            )
            
            if order:
                logger.info(f"Ê≥®ÊñáÂÆüË°åÊàêÂäü: {symbol} {side} {qty} @ {current_price}")
                await self.send_discord_signal(prediction)
            else:
                logger.error(f"Ê≥®ÊñáÂÆüË°åÂ§±Êïó: {symbol} {side}")
                
        except Exception as e:
            logger.error(f"ÂèñÂºïÂÆüË°å„Ç®„É©„Éº: {e}")
            logger.error(traceback.format_exc())
    
    async def monitor_positions(self):
        """„Éù„Ç∏„Ç∑„Éß„É≥„ÇíÁõ£Ë¶ñ"""
        try:
            positions = await self.rest_client.get_open_positions()
            if positions:
                for pos in positions:
                    symbol = pos.get('symbol')
                    size = float(pos.get('size', 0))
                    side = pos.get('side')
                    unrealized_pnl = float(pos.get('unrealisedPnl', 0))
                    
                    logger.info(f"Position {symbol}: {size} {side}, P&L: ${unrealized_pnl:.2f}")
                    
                    # „Çπ„Éà„ÉÉ„Éó„É≠„Çπ/„ÉÜ„Ç§„ÇØ„Éó„É≠„Éï„Ç£„ÉÉ„ÉàÁÆ°ÁêÜÔºàÂ∞ÜÊù•ÂÆüË£ÖÔºâ
                    
        except Exception as e:
            logger.error(f"„Éù„Ç∏„Ç∑„Éß„É≥Áõ£Ë¶ñ„Ç®„É©„Éº: {e}")
    
    async def send_hourly_report(self):
        """ÊôÇÈñìÂà•„É¨„Éù„Éº„Éà„ÇíÈÄÅ‰ø°"""
        if not self.discord_webhook:
            return
        
        try:
            # „Éê„É©„É≥„Çπ„ÇíÊõ¥Êñ∞
            await self.update_balance()
            
            # „Éù„Ç∏„Ç∑„Éß„É≥ÊÉÖÂ†±„ÇíÂèñÂæó
            positions = await self.rest_client.get_open_positions()
            total_unrealized_pnl = 0
            position_details = []
            
            if positions:
                for pos in positions:
                    unrealized_pnl = float(pos.get('unrealisedPnl', 0))
                    total_unrealized_pnl += unrealized_pnl
                    position_details.append(f"{pos.get('symbol')}: ${unrealized_pnl:.2f}")
            
            # Áµ±Ë®àÊÉÖÂ†±„ÇíË®àÁÆó
            stats = self.bias_corrector.get_stats()
            
            # ÂêÑ„Ç∑„É≥„Éú„É´„ÅÆÁµ±Ë®à
            symbol_stats = []
            for symbol in self.symbols:
                if self.hourly_predictions[symbol]:
                    preds = self.hourly_predictions[symbol]
                    buy_count = sum(1 for p in preds if p > 0.5)
                    sell_count = len(preds) - buy_count
                    avg_pred = np.mean(preds)
                    
                    # ÁèæÂú®„ÅÆ‰æ°Ê†º„ÇíÂèñÂæó
                    ticker = await self.rest_client.get_ticker(symbol)
                    price = float(ticker.get('lastPrice', 0)) if ticker else 0
                    
                    symbol_stats.append({
                        "name": symbol,
                        "value": f"Price: ${price:,.2f}\nAvg Pred: {avg_pred:.4f}\nBuy/Sell: {buy_count}/{sell_count}",
                        "inline": True
                    })
            
            # „É°„ÉÉ„Çª„Éº„Ç∏„Çí‰ΩúÊàê
            message = {
                "embeds": [{
                    "title": "üìä ÊôÇÈñì„É¨„Éù„Éº„ÉàÔºà„Éê„Ç§„Ç¢„ÇπË£úÊ≠£ÁâàÔºâ",
                    "description": f"Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M')}",
                    "color": 0x0099ff,
                    "fields": [
                        {
                            "name": "üí∞ „Ç¢„Ç´„Ç¶„É≥„ÉàÊÉÖÂ†±",
                            "value": f"‚Ä¢ ÊÆãÈ´ò: ${self.current_balance:.2f}\n‚Ä¢ „Éù„Ç∏„Ç∑„Éß„É≥Êï∞: {len(positions) if positions else 0}\n‚Ä¢ Êú™ÂÆüÁèæÊêçÁõä: ${total_unrealized_pnl:.2f}",
                            "inline": True
                        },
                        {
                            "name": "üìà ÂèñÂºïÁµ±Ë®à",
                            "value": f"‚Ä¢ ‰∫àÊ∏¨ÂõûÊï∞: {self.prediction_count}\n‚Ä¢ „Ç∑„Ç∞„Éä„É´Êï∞: {self.signal_count}",
                            "inline": True
                        },
                        {
                            "name": "üîß „Éê„Ç§„Ç¢„ÇπË£úÊ≠£",
                            "value": f"‚Ä¢ „Ç™„Éï„Çª„ÉÉ„Éà: {stats.get('offset', 0):.4f}\n‚Ä¢ Buy/SellÊØî: {stats.get('buy_ratio', 0):.1%}/{stats.get('sell_ratio', 0):.1%}",
                            "inline": True
                        }
                    ] + symbol_stats
                }]
            }
            
            async with aiohttp.ClientSession() as session:
                await session.post(self.discord_webhook, json=message)
            
            # ÊôÇÈñìÂà•‰∫àÊ∏¨„Çí„É™„Çª„ÉÉ„Éà
            self.hourly_predictions = {symbol: [] for symbol in self.symbols}
            
            logger.info("ÊôÇÈñìÂà•„É¨„Éù„Éº„ÉàÈÄÅ‰ø°ÂÆå‰∫Ü")
            
        except Exception as e:
            logger.error(f"ÊôÇÈñìÂà•„É¨„Éù„Éº„ÉàÈÄÅ‰ø°„Ç®„É©„Éº: {e}")
    
    async def run(self):
        """„É°„Ç§„É≥„É´„Éº„Éó"""
        await self.initialize()
        
        prediction_interval = 10  # 10Áßí„Åî„Å®„Å´‰∫àÊ∏¨
        position_check_interval = 60  # 1ÂàÜ„Åî„Å®„Å´„Éù„Ç∏„Ç∑„Éß„É≥„ÉÅ„Çß„ÉÉ„ÇØ
        report_interval = 3600  # 1ÊôÇÈñì„Åî„Å®„Å´„É¨„Éù„Éº„Éà
        
        last_position_check = datetime.utcnow()
        
        try:
            while True:
                try:
                    # ÂêÑ„Ç∑„É≥„Éú„É´„Åß‰∫àÊ∏¨
                    for symbol in self.symbols:
                        prediction = await self.predict(symbol)
                        
                        if prediction:
                            # „É≠„Ç∞Âá∫ÂäõÔºà„Éê„Ç§„Ç¢„ÇπË£úÊ≠£ÊÉÖÂ†±„ÇíÂê´„ÇÄÔºâ
                            logger.info(
                                f"üìä {symbol}: raw={prediction['raw_prediction']:.4f}, "
                                f"corrected={prediction['corrected_prediction']:.4f}, "
                                f"conf={prediction['confidence']*100:.2f}%, "
                                f"dir={prediction['direction']}, "
                                f"offset={self.bias_corrector.get_bias_offset():.4f}"
                            )
                            
                            # ÂèñÂºï„Ç∑„Ç∞„Éä„É´„ÉÅ„Çß„ÉÉ„ÇØ
                            if await self.should_send_signal(symbol, prediction['confidence']):
                                await self.execute_trade(prediction)
                    
                    # „Éù„Ç∏„Ç∑„Éß„É≥Áõ£Ë¶ñ
                    now = datetime.utcnow()
                    if (now - last_position_check).total_seconds() >= position_check_interval:
                        await self.monitor_positions()
                        last_position_check = now
                    
                    # ÊôÇÈñìÂà•„É¨„Éù„Éº„Éà
                    if (now - self.last_report_time).total_seconds() >= report_interval:
                        await self.send_hourly_report()
                        self.last_report_time = now
                    
                    # Ê¨°„ÅÆ‰∫àÊ∏¨„Åæ„ÅßÂæÖÊ©ü
                    await asyncio.sleep(prediction_interval)
                    
                except Exception as e:
                    logger.error(f"„É°„Ç§„É≥„É´„Éº„Éó„Ç®„É©„Éº: {e}")
                    logger.error(traceback.format_exc())
                    await asyncio.sleep(30)
                    
        except KeyboardInterrupt:
            logger.info("„Ç∑„É£„ÉÉ„Éà„ÉÄ„Ç¶„É≥‰∏≠...")
        finally:
            await self.cleanup()
    
    async def cleanup(self):
        """„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂá¶ÁêÜ"""
        try:
            if self.rest_client:
                await self.rest_client.__aexit__(None, None, None)
            
            if self.redis_client:
                await self.redis_client.close()
            
            self.feature_generator.close()
            
            logger.info("„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü")
            
        except Exception as e:
            logger.error(f"„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Ç®„É©„Éº: {e}")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='ML Trading Bot with Bias Correction')
    parser.add_argument('--testnet', action='store_true', help='Use testnet')
    args = parser.parse_args()
    
    bot = MLTradingBot(testnet=args.testnet)
    asyncio.run(bot.run())
EOF

# 4. Êñ∞„Åó„ÅÑ„Éú„ÉÉ„Éà„ÇíËµ∑Âãï
echo "üöÄ „Éê„Ç§„Ç¢„ÇπË£úÊ≠£Áâà„Éú„ÉÉ„Éà„ÇíËµ∑Âãï..."
export DISCORD_WEBHOOK='https://discord.com/api/webhooks/1231943231416176692/t1iaVDKtm6WribhzNtYMOPjhMTpN4N9_GGr8NXprcFOjyOH_z5rnnesLqeIAdXJWy6wq'
nohup python3 simple_improved_bot_bias_corrected.py > logs/mlbot_bias_corrected_$(date +%Y%m%d_%H%M%S).log 2>&1 &
NEW_PID=$!

echo "‚úÖ „Éê„Ç§„Ç¢„ÇπË£úÊ≠£Áâà„Éú„ÉÉ„ÉàËµ∑ÂãïÂÆå‰∫Ü (PID: $NEW_PID)"

# 5. Âãï‰ΩúÁ¢∫Ë™ç
sleep 5
echo ""
echo "üìä Âãï‰ΩúÁ¢∫Ë™ç:"
tail -20 logs/mlbot_bias_corrected_*.log | grep -E "(corrected=|offset=|Buy/Sell)"

echo ""
echo "‚úÖ „Éê„Ç§„Ç¢„ÇπË£úÊ≠£ÈÅ©Áî®ÂÆå‰∫ÜÔºÅ"
echo ""
echo "üìà ÊúüÂæÖ„Åï„Çå„ÇãÂäπÊûú:"
echo "  - ‰∫àÊ∏¨ÂÄ§„Åå0.5„Çí‰∏≠ÂøÉ„Å´„Çà„ÇäÂùáÁ≠â„Å´ÂàÜÂ∏É"
echo "  - Buy/SellÊØîÁéá„ÅÆÊîπÂñÑ"
echo "  - „Çà„ÇäÂ§öÊßò„Å™ÂèñÂºï„Ç∑„Ç∞„Éä„É´"

REMOTE_EOF

echo ""
echo "‚úÖ ÂÆå‰∫ÜÔºÅ"